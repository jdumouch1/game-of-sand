#include "../include/sim.h"
#include <bits/stdint-uintn.h>


inline void id_to_uvec2(struct uvec2 *out, size_t local_id){
    out->x = local_id % CHUNK_SIZE;
    out->y = local_id >> CHUNK_SCALE;

    // Note: CHUNK_SIZE is a power of two and division is optimized by
    // using a left shift by Log2(CHUNK_SIZE), which happens to be CHUNK_SCALE
}

inline size_t uvec2_to_id(struct uvec2 *v){
    return v->x + (v->y << CHUNK_SCALE);
    
    // Note: Id is calculated as the x + y * row_size, 
    // y * row_size is optimized by using y << Log2(CHUNK_SIZE), known to be
    // y << CHUNK_SCALE
}

int chunk_raycast(struct chunk *c, int *id, 
                      uint32_t *distance, int delta){
    int start = *id;
    uint8_t max_distance = *distance;
    for (int i = 0; i < max_distance; i++){
        if ((*id+delta) < 0 ||  
            c->mesh[*id+delta].kind){ break; }
        
        *distance -= 1;
        *id += delta;
    }
    
    return *id != start;
}

void cell_swap(struct cell *a, struct cell *b){
    struct cell tmp = *b;
    memcpy(b, a, sizeof(struct cell));
    memcpy(a, &tmp, sizeof(struct cell));
}

int cell_can_move(struct cell *a, struct cell *b) {
    uint8_t a_density = kinds[a->kind].density;
    uint8_t b_density = kinds[b->kind].density;

    if (a_density > b_density){
        return 1;
    }else{
        return 0;        
    }
}

void cell_update(struct chunk *c, size_t local_id){
   // Calculate local coords of cell.
    struct uvec2 pos;
    id_to_uvec2(&pos, local_id);
    if (!pos.y) { return; }
    
    // Get cell data
    struct cell *cell = &c->mesh[local_id];
    struct kind_property props = kinds[cell->kind]; 
   
    // How far the cell can travel this update
    int travel = CELL_VELOCITY(cell->data)+1;

    // Move the cell down until it runs out of travel, or can't move
    while (travel){
        size_t new_id;
        // First test if the cell can move down
        struct cell *test_cell = &c->mesh[local_id + off_d];
        if (cell_can_move(cell, test_cell)){
            new_id = local_id + off_d;
        } 
        // Then test the sides
        else {
            travel >>= 2;
            CELL_VELOCITY_SET(cell->data, CELL_VELOCITY(cell->data)>>1);
            // Choose a random side to start
            int test_id = rand()%2;
            struct cell *test_cells[2] = {
                &c->mesh[local_id + off_dl],
                &c->mesh[local_id + off_dr],
            };
            // Left
            if (cell_can_move){
            }
            // Right
            else if(){

            }
            // Cant move, set vel to 0 and don't move
            else{
                CELL_VELOCITY_CLR(cell->data);
                break;
            }

            // Cell could not move to either downleft or downright
        }

        struct cell *new_cell = &c->mesh[new_id];
        cell_swap(new_cell, cell);
        // TODO: update the old cell pos?
        c->updated[new_id] |= 1;
            
    }
}

void chunk_update(struct chunk *c){
    // Reset the cell updated states
    memset(&c->updated, 0, sizeof(c->updated));
    // Generate an odd number in (0, CHUNK_SIZE)
    // Using the definition of odd numbers a = (2b)+1
    // b = CHUNK_SIZE/2 - 1 (because of the +1 at the end)
    size_t coprime = (rand() % (CHUNK_SIZE/2-1)) * 2 + 1;
    
    // Set the chunk to inactive, in case no cells are updated.
    c->flags &= ~(CHUNK_FLAG_ACTIVE);   

    // Loop through each cell in random order
    size_t i = 0;
    while ( i < CHUNK_AREA ) {
        // Generate a unique index using (a*x) % n
        // Provided i reaches all values up to n, will 
        // generate every number up to n, with a pseudo-random offset
        size_t next = (i * coprime) % CHUNK_AREA;
        struct cell *cell = &c->mesh[next];

        // Check if the cell exists and has not settled
        if (cell->kind && 
            !CHK_FLAG(cell->data, CELL_SETTLED_FLAG) && 
            !c->updated[next]){
            cell_update(c, next);

            c->flags |= 0x1; // Given that a cell has moved, the chunk
                             // must be active.
        }

        i++;
    }
}
